/-
Copyright (c) 2019 Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Simon Hudon, Scott Morrison, Keeley Hoek, Robert Y. Lewis,
Floris van Doorn, E.W.Ayers, Arthur Paulino
-/
import Lean
import Batteries.Lean.Expr
import Batteries.Data.List.Basic

namespace Lean

namespace Name

/-! ### Declarations about `name` -/


/-- `isPrefixOf? pre nm` returns `some post` if `nm = pre ++ post`.
  Note that this includes the case where `nm` has multiple more namespaces.
  If `pre` is not a prefix of `nm`, it returns `none`. -/
private def isPrefixOf? (pre nm : Name) : Option Name :=
  if pre == nm then
    some anonymous
  else match nm with
  | anonymous => none
  | num p' a => (isPrefixOf? pre p').map (·.num a)
  | str p' s => (isPrefixOf? pre p').map (·.str s)

/-- Lean 4 makes declarations which are technically not internal
(that is, head string does not start with `_`) but which sometimes should
be treated as such. For example, the `to_additive` attribute needs to
transform `proof_1` constants generated by `Lean.Meta.mkAuxDefinitionFor`.
This might be better fixed in core, but until then, this method can act
as a polyfill. This method only looks at the name to decide whether it is probably internal.
Note: this declaration also occurs as `shouldIgnore` in the Lean 4 file `test/lean/run/printDecls`.
-/
private def isInternal' (declName : Name) : Bool :=
  declName.isInternal ||
  match declName with
  | .str _ s => "match_".isPrefixOf s || "proof_".isPrefixOf s
  | _        => true

end Lean.Name

namespace Loogle

open Lean Meta

-- from Lean.Server.Completion
-- This definition is copied all over the place; let's hope we eventually
-- get an authoritive version in std, or an explicit attribute in core

def isBlackListed {m} [Monad m] [MonadEnv m] (declName : Name) : m Bool := do
  if declName == ``sorryAx then return true
  if declName matches .str _ "ctorIdx" then return true
  if declName matches .str _ "inj" then return true
  if declName matches .str _ "noConfusion" then return true
  if declName matches .str _ "noConfusionType" then return true
  if declName matches .str (.str _ "noConfusionType") _ then return true
  let env ← getEnv
  pure $ declName.isInternal'
   || isAuxRecursor env declName
   || isNoConfusion env declName
  <||> isRec declName <||> isMatcher declName

end Loogle
